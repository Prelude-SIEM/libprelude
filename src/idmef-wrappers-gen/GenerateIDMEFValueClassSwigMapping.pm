# Copyright (C) 2003-2020 CS-SI. All Rights Reserved.
# Author: Yoann Vandoorselaere <yoann.v@prelude-ids.com>
#
# This file is part of the Prelude library.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation; either version 2.1, or (at your option)
# any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

package GenerateIDMEFValueClassSwigMapping;

use Generate;
@ISA = qw/Generate/;

use strict;
use IDMEFTree; 


sub	header
{
    my	$self = shift;

    $self->output("
/*****
*
* Copyright (C) 2005-2020 CS-SI. All Rights Reserved.
* Author: Yoann Vandoorselaere <yoann.v\@prelude-ids.com>
*
* This file is part of the Prelude library.
*
* This program is free software; you can redistribute it and/or modify
* it under the terms of the GNU Lesser General Public License as published by
* the Free Software Foundation; either version 2.1, or (at your option)
* any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public License along
* with this program; if not, write to the Free Software Foundation, Inc.,
* 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
*
*****/

/* Auto-generated by the GenerateIDMEFValueClassSwigMapping package */

");
}



sub	footer
{
    my	$self = shift;
    my	$tree = shift;
    my	$last_id = -1;
    my  $object_class;

    $self->output("

%{

void *swig_idmef_value_get_descriptor(idmef_value_t *value)
{
        unsigned int i = 0;
        idmef_class_id_t wanted_class = idmef_value_get_class(value);
	const struct {
	        idmef_class_id_t class;
	        const char *typename;
	} tbl[] = {
");
    
    foreach my $obj ( sort { $a->{id} <=> $b->{id} } map { 
                      ($_->{obj_type} != &OBJ_PRE_DECLARED ? $_ : () ) } @{ $tree->{obj_list} } ) {

       if ( $obj->{obj_type} == &OBJ_STRUCT ) { 
           $object_class = "IDMEF_CLASS_ID_" . uc("$obj->{short_typename}");
           $self->output("                { $object_class, \"$obj->{typename} *\" },\n");
       }
    }
  
    $self->output("                { 0, NULL }
        };

        for ( i = 0; tbl[i].typename != NULL; i++ ) {
                if ( tbl[i].class == wanted_class )
		        return SWIG_TypeQuery(tbl[i].typename);
        }

        return NULL;
}

%}
");

}

1;
