# Copyright (C) 2016-2020 CS-SI. All Rights Reserved.
# Author: Yoann Vandoorselaere <yoannv@gmail.com>
#
# This file is part of the Prelude library.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2, or (at your option)
# any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

package GenerateIDMEFMessageReadJSONC;

use Generate;
@ISA = qw/Generate/;

use strict;
use IDMEFTree;

sub     header
{
     my $self = shift;

     $self->output("
/*****
*
* Copyright (C) 2016-2020 CS-SI. All Rights Reserved.
* Author: Yoann Vandoorselaere <yoannv\@gmail.com>
*
* This file is part of the Prelude library.
*
* This program is free software; you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation; either version 2, or (at your option)
* any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License along
* with this program; if not, write to the Free Software Foundation, Inc.,
* 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
*
*****/

/* Auto-generated by the GenerateIDMEFMessageReadJSONC package */
#include \"config.h\"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include \"prelude-error.h\"
#include \"prelude-inttypes.h\"
#include \"prelude-list.h\"
#include \"prelude-extract.h\"
#include \"prelude-io.h\"
#include \"idmef-message-id.h\"
#include \"idmef.h\"
#include \"idmef-tree-wrap.h\"
#include \"common.h\"

#define JSMN_PARENT_LINKS

#include \"jsmn/jsmn.h\"
#include \"jsmn/jsmn.c\"

#ifndef MIN
# define MIN(x, y) ((x) < (y) ? (x) : (y))
#endif

typedef struct {
        const char *input;
        jsmntok_t jtok[1024];
        int jtoksize;
        unsigned int idx;
\} json_data_t;


static int idmef_linkage_read_json(idmef_linkage_t *linkage, json_data_t *ctrl);


static const char *jsmn_type_to_string(int type)
{
        switch(type) {
            case JSMN_STRING:
                return \"string\";
            case JSMN_PRIMITIVE:
                return \"primitive\";
            case JSMN_OBJECT:
                return \"object\";
            case JSMN_ARRAY:
                return \"array\";
            default:
                return \"unknown\";
        }
}


static int unescape_string(prelude_string_t *out, const char *in, size_t size)
{
        int ret;
        const char *end = in + size;

        for ( ; in < end; in++ ) {
                if ( *in != '\\\\' ) {
                        ret = prelude_string_ncat(out, in, 1);
                        continue;
                }

                in++;
                switch(*in) {
                        case '\"':
                        case '/':
                        case '\\\\':
                                ret = prelude_string_ncat(out, in, 1);
                                break;

                        case 'b':
                                ret = prelude_string_ncat(out, \"\\b\", 1);
                                break;
                        case 't':
                                ret = prelude_string_ncat(out, \"\\t\", 1);
                                break;
                        case 'n':
                                ret = prelude_string_ncat(out, \"\\n\", 1);
                                break;
                        case 'f':
                                ret = prelude_string_ncat(out, \"\\f\", 1);
                                break;
                        case 'r':
                                ret = prelude_string_ncat(out, \"\\r\", 1);
                                break;

                        case 'u': {
                                ret = prelude_unicode_to_string(out, in - 2, end - (in - 2));
                                if ( ret < 0 )
                                        return ret;

                                in += ret - 1;
                                break;
                        }

                        default:
                                ret = prelude_string_ncat(out, in, 1);
                                break;
                }

                if ( ret < 0 )
                        return ret;
        }

        return 0;
}


static int __get_float(json_data_t *ctrl, float *value)
{
        char *end = NULL;
        jsmntok_t *j = &ctrl->jtok[ctrl->idx];
        size_t len = j->end - j->start;
        const char *str = ctrl->input + j->start;

        *value = strtof(ctrl->input + j->start, &end);
        if ( end != (str + len) )
                return prelude_error_verbose(PRELUDE_ERROR_GENERIC, \"error decoding to real\");

        return 0;
\}



static int __get_integer(json_data_t *ctrl, int64_t *out)
{
        char *end = NULL;
        jsmntok_t *j = &ctrl->jtok[ctrl->idx];
        size_t len = j->end - j->start;
        const char *str = ctrl->input + j->start;

        if ( j->type != JSMN_PRIMITIVE )
                return prelude_error_verbose(PRELUDE_ERROR_GENERIC, \"expected JSON integer got '%s'\", jsmn_type_to_string(j->type));

        *out = strtoll(ctrl->input + j->start, &end, 10);
        if ( end != (str + len) )
                return prelude_error_verbose(PRELUDE_ERROR_GENERIC, \"error decoding to integer\");

        return 0;
\}


static int __get_string_copy(json_data_t *ctrl, unsigned int idx, char *out, size_t size)
{
        size_t insize;
        jsmntok_t *j = &ctrl->jtok[idx];
        const char *input = ctrl->input + j->start;

        insize = j->end - j->start;

        if ( insize == 0 ) {
                *out = '\\0';
                return 0;
        }

        else if ( insize >= size )
                return prelude_error_verbose(PRELUDE_ERROR_GENERIC, \"buffer is too small\");

        strncpy(out, input, MIN(size, j->end - j->start));
        out[j->end - j->start] = 0;

        return 0;
}

static int __get_string(json_data_t *ctrl, prelude_string_t *out)
{
        jsmntok_t *j = &ctrl->jtok[ctrl->idx];
        const char *input = ctrl->input + j->start;

        if ( j->type != JSMN_STRING )
                return prelude_error_verbose(PRELUDE_ERROR_GENERIC, \"JSON value is not string : %s\", jsmn_type_to_string(j->type));

        if ( j->end - j->start == 0 )
                return 0;

        return unescape_string(out, input, j->end - j->start);
\}


static int jsoneq(json_data_t *data, jsmntok_t *tok, const char *wanted)
{
    size_t size = tok->end - tok->start;
    const char *start = data->input + tok->start;

    if ( tok->type == JSMN_STRING && strlen(wanted) == size && strncmp(start, wanted, size) == 0)
            return 0;

    return prelude_error_verbose(PRELUDE_ERROR_GENERIC, \"jsoneq failed\");
\}



static int __get_json_key(json_data_t *ctrl, const char *wanted, unsigned int sidx)
{
        unsigned int i;

        for ( i = 0; i < ctrl->jtok[sidx].size * 2; i++ ) {
                if ( jsoneq(ctrl, &ctrl->jtok[sidx + i], wanted) == 0 )
                        return i;
        }

        return prelude_error_verbose(PRELUDE_ERROR_GENERIC, \"failed to get json key '%s'\", wanted);
}
");
}

sub     struct_field_normal
{
    my  $self = shift;
    my  $tree = shift;
    my  $struct = shift;
    my  $field = shift;
    my  $type = shift || $field->{value_type};
    my  $var_type = shift || "$field->{typename}";

    if ( $field->{metatype} & &METATYPE_LIST ) {
        if ( $field->{metatype} & &METATYPE_ENUM ){
                $self->output("
                                        char buf[128];

                                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                                        if ( ret < 0 )
                                                return ret;

                                        int ret = idmef_$struct->{short_typename}_$field->{short_name}_to_numeric(buf);
                                        if ( ret != -1 )
                                                idmef_$struct->{short_typename}_set_$field->{short_name}($struct->{short_typename}, ret, IDMEF_LIST_APPEND);
");
        } elsif ( $field->{metatype} & &METATYPE_OPTIONAL_INT ){
                $self->output("{
                                        int ret;
                                        int64_t out;

                                        ret = __get_integer(ctrl, &out);
                                        if ( ret < 0 )
                                                return ret;

                                        idmef_$struct->{short_typename}_set_$field->{short_name}($struct->{short_typename}, out, IDMEF_LIST_APPEND);
                              \}
");
        } else {
                $self->output("
                                        int ret;
                                        prelude_string_t *str;

                                        ret = idmef_$struct->{short_typename}_new_$field->{short_name}($struct->{short_typename}, &str, IDMEF_LIST_APPEND);
                                        if ( ret < 0 )
                                                return ret;

                                        ret = __get_string(ctrl, str);
                                        if ( ret < 0 )
                                                return ret;
");
        }

        $self->output("
                                                            ctrl->idx += 1;
                    \}

                                                ctrl->idx -= 1;
                                                ");

    } else {
        if ( $field->{metatype} & &METATYPE_ENUM ){
                $self->output("
                        int ret;
                        char buf[128];

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = idmef_$struct->{short_typename}_$field->{short_name}_to_numeric(buf);
                        if ( ret != -1 )
                                idmef_$struct->{short_typename}_set_$field->{short_name}($struct->{short_typename}, ret);
");
        } elsif ( $field->{metatype} & &METATYPE_OPTIONAL_INT ){
                $self->output("
                        int ret;
                        int64_t out;

                        ret = __get_integer(ctrl, &out);
                        if ( ret < 0 )
                                return ret;

                        idmef_$struct->{short_typename}_set_$field->{short_name}($struct->{short_typename}, out);
");
        } elsif ( $field->{typename} eq "idmef_time_t" ){
                $self->output("
                        int ret;
                        char buf[128];
                        idmef_time_t *time;

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = idmef_time_new_from_string(&time, buf);
                        if (ret < 0)
                                return ret;

                        idmef_$struct->{short_typename}_set_$field->{short_name}($struct->{short_typename}, time);
");

        } elsif ( $field->{typename} eq "idmef_data_t" ){
            if ( not $struct->{short_typename} eq "additional_data" ) {
                $self->output("
                        int ret;
                        idmef_data_t *data;
                        prelude_string_t *str;

                        ret = idmef_$struct->{short_typename}_new_$field->{short_name}($struct->{short_typename}, &data);
                        if ( ret < 0 )
                                return ret;

                        ret = prelude_string_new(&str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 ) {
                                prelude_string_destroy(str);
                                return ret;
                        }

                        ret = idmef_data_set_byte_string_dup(data, (const unsigned char *) prelude_string_get_string(str), prelude_string_get_len(str));
                        prelude_string_destroy(str);
");
            } else {
                $self->output("
                        int ret;
                        char buf[128];
                        idmef_data_t *data;
                        idmef_additional_data_type_t type;

                        ret = __get_json_key(ctrl, \"type\", obj_idx);
                        if ( ret < 0 )
                                return prelude_error_verbose(PRELUDE_ERROR_GENERIC, \"type argument required for additional data object\");

                        ret = __get_string_copy(ctrl, obj_idx + ret + 1, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        type = idmef_additional_data_type_to_numeric(buf);
                        if ( type < 0 )
                                return type;

                        ret = idmef_$struct->{short_typename}_new_$field->{short_name}($struct->{short_typename}, &data);
                        if ( ret < 0 )
                                return ret;

                        switch(type) {
                                case IDMEF_ADDITIONAL_DATA_TYPE_REAL: {
                                        float val;

                                        ret = __get_float(ctrl, &val);
                                        if ( ret < 0 )
                                                return ret;

                                        idmef_data_set_float(data, val);
                                        break;
                                }

                                case IDMEF_ADDITIONAL_DATA_TYPE_BYTE:
                                case IDMEF_ADDITIONAL_DATA_TYPE_BOOLEAN:
                                case IDMEF_ADDITIONAL_DATA_TYPE_NTPSTAMP:
                                case IDMEF_ADDITIONAL_DATA_TYPE_INTEGER: {
                                        int ret;
                                        int64_t val;

                                        ret = __get_integer(ctrl, &val);
                                        if ( ret < 0 )
                                                return ret;

                                        idmef_data_set_int(data, val);
                                        break;
                                }

                                case IDMEF_ADDITIONAL_DATA_TYPE_DATE_TIME: {
                                        idmef_time_t *time;
                                        char buf[128];

                                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                                        if ( ret < 0 )
                                                return ret;

                                        ret = idmef_time_new_from_string(&time, buf);
                                        if ( ret < 0 )
                                                return ret;

                                        idmef_data_set_time(data, time);
                                        break;
                                }

                                case IDMEF_ADDITIONAL_DATA_TYPE_STRING:
                                case IDMEF_ADDITIONAL_DATA_TYPE_BYTE_STRING:
                                case IDMEF_ADDITIONAL_DATA_TYPE_CHARACTER:
                                case IDMEF_ADDITIONAL_DATA_TYPE_PORTLIST:
                                case IDMEF_ADDITIONAL_DATA_TYPE_XML: {
                                        prelude_string_t *str;

                                        ret = prelude_string_new(&str);
                                        if ( ret < 0 )
                                                return ret;

                                        ret = __get_string(ctrl, str);
                                        if ( ret < 0 ) {
                                                prelude_string_destroy(str);
                                                return ret;
                                        }

                                        if ( type == IDMEF_ADDITIONAL_DATA_TYPE_BYTE_STRING )
                                                ret = idmef_data_set_byte_string_dup(data, (const unsigned char *) prelude_string_get_string(str), prelude_string_get_len(str));
                                        else
                                                ret = idmef_data_set_char_string_dup_fast(data, prelude_string_get_string(str), prelude_string_get_len(str));

                                        prelude_string_destroy(str);
                                        break;
                                }

                                default:
                                        return prelude_error_verbose(PRELUDE_ERROR_GENERIC, \"unhandled IDMEF additional data type\");
;
                        }
");
            }
        } elsif ( $field->{typename} eq "float" ){
                $self->output("
                        int ret;
                        float *value;

                        ret = idmef_$struct->{short_typename}_new_$field->{short_name}($struct->{short_typename}, &value);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_float(ctrl, value);
                        if ( ret < 0 )
                                return ret;
");
        } else {
                $self->output("
                        int ret;
                        prelude_string_t *str;

                        ret = idmef_$struct->{short_typename}_new_$field->{short_name}($struct->{short_typename}, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
");

        }


    }
}

sub     struct_field_struct
{
    my  $self = shift;
    my  $tree = shift;
    my  $struct = shift;
    my  $field = shift;
    my  $name = shift || $field->{name};

    if ( $field->{metatype} & &METATYPE_LIST ) {
           $self->output("
                                                int ret;
                                                idmef_${name}_t *${name};

                                                ret = idmef_$struct->{short_typename}_new_${name}($struct->{short_typename}, &${name}, IDMEF_LIST_APPEND);
                                                if ( ret < 0 )
                                                        return ret;

                                                ret = idmef_${name}_read_json(${name}, ctrl);
                                                if ( ret < 0 )
                                                        return ret;
                                        }
                                ctrl->idx -= 1;
");
    } else {
           $self->output("
                        int ret;
                        idmef_${name}_t *${name};

                        ret = idmef_$struct->{short_typename}_new_${name}($struct->{short_typename}, &${name});
                        if ( ret < 0 )
                                return ret;

                        ret = idmef_${name}_read_json(${name}, ctrl);
                        if ( ret < 0 )
                                return ret;

                        ctrl->idx -= 1;
");
    }
}

sub     struct_field_union
{
    my  $self = shift;
    my  $tree = shift;
    my  $struct = shift;
    my  $field = shift;
    my  $i = shift || 0;

    foreach my $member ( @{$field->{member_list}} ) {
        $i += 1;
        if ( $i == 1 ) {
            $self->output("
                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], \"$member->{name}\") == 0){
                        ctrl->idx++;
");
        } else {
            $self->output("
                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], \"$member->{name}\") == 0){
                        ctrl->idx++;
");
        }
        $self->struct_field_struct($tree, $struct, $member);
        $self->output("
                }
");
    }
}

sub     struct
{
    my  $self = shift;
    my  $tree = shift;
    my  $struct = shift;
    my  $i = 0;

    $self->output("
/**
 * idmef_$struct->{short_typename}_read:
 * \@$struct->{short_typename}: Pointer to a #$struct->{typename} object.
 * \@json: Pointer to a #json_t object, containing a message.
 *
 * Read an idmef_$struct->{short_typename} from the \@json message, and
 * store it into \@$struct->{short_typename}.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
static int idmef_$struct->{short_typename}_read_json($struct->{typename} *$struct->{short_typename}, json_data_t *ctrl)
\{
        unsigned int i = 0;
        size_t size = ctrl->jtok[ctrl->idx].size;
");


if ( $struct->{short_typename} eq "additional_data" ) {
        $self->output("
                unsigned int obj_idx = ctrl->idx;
");
}

$self->output("
        if ( ctrl->jtok[ctrl->idx].type != JSMN_OBJECT )
                return prelude_error_verbose(PRELUDE_ERROR_GENERIC, \"expected JSON object got '%s'\", jsmn_type_to_string(ctrl->jtok[ctrl->idx].type));

        for ( ctrl->idx += 1; i < size && ctrl->idx < ctrl->jtoksize; ctrl->idx++, i++ ) {
                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], \"_self\") == 0 ) {
                        ctrl->idx++;
                        continue;
                }
");

    foreach my $field ( @{$struct->{field_list}} ) {
        my $name = ($field->{metatype} & (&METATYPE_STRUCT | &METATYPE_LIST)) ? $field->{short_name} : $field->{name};

        unless ( $field->{metatype} & &METATYPE_UNION ) {
            $i += 1;
            if ( $i == 1 ) {
                $self->output("
                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], \"${name}\") == 0 ) {
                        ctrl->idx++;
");
            } else {
                $self->output("
                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], \"${name}\") == 0 ) {
                        ctrl->idx++;
");

            }
        }

        if ( $field->{metatype} & &METATYPE_NORMAL ) {

            if ( $field->{metatype} & &METATYPE_PRIMITIVE ) {
                $self->struct_field_normal($tree, $struct, $field);

            } elsif ( $field->{metatype} & &METATYPE_ENUM ) {
                $self->struct_field_normal($tree, $struct, $field, "int32", "int32_t");

            } else {
                $self->struct_field_struct($tree, $struct, $field);
            }
            $self->output("
                }
");

        } elsif ( $field->{metatype} & &METATYPE_LIST ) {
            $self->output("
                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {
");

            if ( $field->{metatype} & &METATYPE_PRIMITIVE ) {
                $self->struct_field_normal($tree, $struct, $field);

            } else {
                $self->struct_field_struct($tree, $struct, $field, $field->{short_name});
            }
            $self->output("
                        }
                }
");

        } elsif ( $field->{metatype} & &METATYPE_UNION ) {
            $self->struct_field_union($tree, $struct, $field, $i);
        }

    }

    $self->output("
                else {
                        return prelude_error_verbose(PRELUDE_ERROR_GENERIC, \"unexpected field '%.*s' while reading $struct->{short_typename}\", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start);
                }
        }

        return 0;
\}
");
}

sub        footer
{
    my        $self = shift;
    my        $tree = shift;
    my        $first = 1;

    $self->output("
int idmef_object_new_from_json(idmef_object_t **object, const char *json_message)
{
        int ret, selfkey;
        jsmn_parser parser;
        json_data_t ctrl;

        jsmn_init(&parser);
        ctrl.idx = 0;
        ctrl.input = json_message;

        ret = ctrl.jtoksize = jsmn_parse(&parser, json_message, strlen(json_message), ctrl.jtok, sizeof(ctrl.jtok) / sizeof(*ctrl.jtok));
        if ( ret < 0 )
                return prelude_error_verbose(PRELUDE_ERROR_GENERIC, \"JSON parser error\");

        selfkey = __get_json_key(&ctrl, \"_self\", 0);
        if ( selfkey < 0 ) {
                ret = idmef_message_new((idmef_message_t **) object);
                if ( ret < 0 )
                        return ret;

                ret = idmef_message_read_json(*(idmef_message_t **) object, &ctrl);
                if ( ret < 0 ) {
                        idmef_message_destroy(*(idmef_message_t **) object);
                        return prelude_error_verbose(PRELUDE_ERROR_GENERIC, \"json message miss '_self' attribute and is not a complete message\");
                }

                return ret;
        }
");


foreach my $obj ( sort { $a->{id} <=> $b->{id} } map { ($_->{obj_type} != &OBJ_PRE_DECLARED ? $_ : () ) } @{ $tree->{obj_list} } ) {

        if ( $obj->{obj_type} == &OBJ_STRUCT ) {
                if ( ! $first ) {
                    $self->output("else ");
                } else {
                    $first = 0;
                }

                $self->output("
        if ( jsoneq(&ctrl, &ctrl.jtok[selfkey + 1], \"$obj->{typename}\") == 0 ) {
                ret = idmef_$obj->{short_typename}_new((idmef_$obj->{short_typename}_t **) object);
                if ( ret < 0 )
                        return ret;

                ret = idmef_$obj->{short_typename}_read_json((idmef_$obj->{short_typename}_t *) *object, &ctrl);
        }
        ");
        }
}

$self->output("
        else {
                ret = prelude_error_verbose(PRELUDE_ERROR_GENERIC, \"unknown object type '%s'\", \"\");
        }

        return ret;
}

")
}

1;
