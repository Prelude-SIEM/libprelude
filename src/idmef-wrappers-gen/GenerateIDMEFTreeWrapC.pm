# Copyright (C) 2003-2019 CS-SI. All Rights Reserved.
# Author: Nicolas Delon <nicolas.delon@prelude-ids.com>
#
# This file is part of the Prelude library.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2, or (at your option)
# any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

package GenerateIDMEFTreeWrapC;

use Generate;
@ISA = qw/Generate/;

use strict;
use IDMEFTree;

sub     header
{
    my  $self = shift;
    my  $file = $self->{file};

    $self->output("
/*****
*
* Copyright (C) 2001-2019 CS-SI. All Rights Reserved.
* Author: Yoann Vandoorselaere <yoann.v\@prelude-ids.com>
* Author: Nicolas Delon <nicolas.delon\@prelude-ids.com>
*
* This file is part of the Prelude library.
*
* This program is free software; you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation; either version 2, or (at your option)
* any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License along
* with this program; if not, write to the Free Software Foundation, Inc.,
* 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
*
*****/

/* Auto-generated by the GenerateIDMEFTreeWrapC package */

#include \"config.h\"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/types.h>

#include \"prelude-inttypes.h\"
#include \"prelude-list.h\"
#include \"prelude-msg.h\"
#include \"prelude-string.h\"

#define PRELUDE_ERROR_SOURCE_DEFAULT PRELUDE_ERROR_SOURCE_IDMEF_TREE_WRAP
#include \"prelude-error.h\"

#include \"idmef-time.h\"
#include \"idmef-data.h\"
#include \"idmef-class.h\"
#include \"idmef-value.h\"
#include \"idmef-object-prv.h\"

#include \"idmef-tree-wrap.h\"
#include \"libmissing.h\"
#include \"common.h\"

#ifdef WIN32
# undef interface
#endif


#define LISTED_OBJECT(name, type) prelude_list_t name
#define KEYLISTED_OBJECT(name, type) prelude_list_t name

#define IS_KEY_LISTED(keyfield) IDMEF_LINKED_OBJECT; prelude_string_t *keyfield

#define UNION(type, var) type var; union

#define UNION_MEMBER(value, type, name) type name

#define ENUM(...) typedef enum

#define PRE_DECLARE(type, class)

#define TYPE_ID(type, id) type

#define PRIMITIVE_TYPE(type)
#define PRIMITIVE_TYPE_STRUCT(type)

#define HIDE(type, name) type name

#define REFCOUNT int refcount
#define REQUIRED(type, name) type name
#define IGNORED(type, name) type name

#define DYNAMIC_IDENT(x) uint64_t x

#define OPTIONAL_INT(type, name) type name; unsigned int name ## _is_set:1

#define DISPLAY_ATTRS(...)

#define IDENT(name) uint64_t name


#define idmef_data_copy idmef_data_copy_dup

#ifndef ABS
# define ABS(x) (((x) < 0) ? -(x) : (x))
#endif


/*
 * If we subtract the integer representations of two floats then that
 * will tell us how close they are. If the difference is zero, they are
 * identical. If the difference is one, they are adjacent floats.
 * In general, if the difference is n then there are n-1 floats between
 * them.
 *
 * http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm
 */
static int float_compare(float a, float b)
{
        union {
                float fval;
                int32_t ival;
        } au, bu;

        au.fval = a;
        bu.fval = b;

        /* Make aInt lexicographically ordered as a twos-complement int */
        if ( au.ival < 0 )
                au.ival = 0x80000000 - au.ival;

        /* Make bInt lexicographically ordered as a twos-complement int */
        if ( bu.ival < 0 )
                bu.ival = 0x80000000 - bu.ival;

        return (ABS(au.ival - bu.ival) <= 0) ? 0 : -1;
}



static int prelude_string_copy(const prelude_string_t *src, prelude_string_t *dst)
{
        prelude_return_val_if_fail(src, prelude_error(PRELUDE_ERROR_ASSERTION));
        prelude_return_val_if_fail(dst, prelude_error(PRELUDE_ERROR_ASSERTION));

        if ( ! prelude_string_is_empty(src) )
               return prelude_string_copy_dup(src, dst);

        return 0;
}



static int get_value_from_string(idmef_value_t **value, prelude_string_t *str, prelude_bool_t is_ptr)
{
        int ret;

        if ( ! str ) {
                *value = NULL;
                return 0;
        }

        if ( ! is_ptr ) {
                ret = prelude_string_clone(str, &str);
                if ( ret < 0 )
                        return ret;
        }

        ret = idmef_value_new_string(value, str);
        if ( ret < 0 ) {
                prelude_string_destroy(str);
                return ret;
        }

        if ( is_ptr )
                prelude_string_ref(str);

        return 0;
}



static int get_value_from_data(idmef_value_t **value, idmef_data_t *data, prelude_bool_t is_ptr)
{
        int ret;

        if ( ! data ) {
                *value = NULL;
                return 0;
        }

        if ( ! is_ptr ) {
                ret = idmef_data_clone(data, &data);
                if ( ret < 0 )
                        return ret;
        }

        ret = idmef_value_new_data(value, data);
        if ( ret < 0 ) {
                idmef_data_destroy(data);
                return ret;
        }

        if ( is_ptr )
                idmef_data_ref(data);

        return 0;
}


static int get_value_from_time(idmef_value_t **value, idmef_time_t *time, prelude_bool_t is_ptr)
{
        int ret;

        if ( ! time ) {
                *value = NULL;
                return 0;
        }

        if ( ! is_ptr ) {
                ret = idmef_time_clone(time, &time);
                if ( ret < 0 )
                        return ret;
        }

        ret = idmef_value_new_time(value, time);
        if ( ret < 0 ) {
                idmef_time_destroy(time);
                return ret;
        }

        if ( is_ptr )
                idmef_time_ref(time);

        return 0;
}


static void list_insert(prelude_list_t *head, prelude_list_t *item, int pos)
{
        int i = 0;
        prelude_list_t *tmp;

        if ( pos == IDMEF_LIST_APPEND )
                prelude_list_add_tail(head, item);

        else if ( pos == IDMEF_LIST_PREPEND )
                prelude_list_add(head, item);

        else if ( pos >= 0 ) {
                prelude_list_for_each(head, tmp) {
                        if ( i == pos )
                                break;
                        i++;
                }

                prelude_list_add_tail(tmp, item);
        }

        else if ( pos < 0 ) {
                pos = -pos;
                pos--;

                prelude_list_for_each_reversed(head, tmp) {
                        if ( i == pos )
                                break;
                        i++;
                }

                prelude_list_add(tmp, item);
        }
}

");
}

sub     struct_desc
{
    my  $self = shift;
    my  $tree = shift;
    my  $struct = shift;
    my $line;

    $self->output("\n\nstruct idmef_$struct->{short_typename} \{
");

    foreach ( @{ $struct->{desc} } ) {
        $line = $_;
        $line =~ s/.*TYPE_ID.*//;
        $line =~ s/struct \{//;
    $self->output(" $line\n");

    }
    #$self->output(" $_\n") foreach ( @{ $struct->{desc} } ~ s/.*TYPE_ID.*// );
    $self->output("\};\n\n");
}

sub     struct_constructor
{
    my  $self = shift;
    my  $tree = shift;
    my  $struct = shift;

    my $maj = uc($struct->{short_typename});

    $self->output("
/**
 * idmef_$struct->{short_typename}_new:
 * \@ret: Pointer where to store the created #$struct->{typename} object.
 *
 * Create a new #$struct->{typename} object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmef_$struct->{short_typename}_new($struct->{typename} **ret)
\{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return prelude_error_from_errno(errno);

        (*ret)->_idmef_object_id = IDMEF_CLASS_ID_$maj;
");

    if ( $struct->{is_listed} ) {
        $self->output("
        prelude_list_init(&((prelude_linked_object_t *) (*ret))->_list);
");
    }

    if ( $struct->{refcount} ) {
        $self->output("
        (*ret)->refcount = 1;
");
    }


    foreach my $field ( map { $_->{metatype} & &METATYPE_LIST ? $_ : () } @{ $struct->{field_list} } ) {

        $self->output("
        prelude_list_init(&(*ret)->$field->{name});

");

    }

    foreach my $field ( @{ $struct->{field_list} } ) {
        my $prefix = "";

        if ( $field->{typename} ne "prelude_string_t" and !($field->{metatype} & (&METATYPE_PRIMITIVE)) ) {
                $prefix = "idmef_";
        }

        if ( $field->{required} ) {
                $self->output("
        {
");
        #if ( $field->{name} eq "version" ) {
                #$self->output("                int retval = prelude_string_new_ref_fast(&(*ret)->$field->{name}, \"1.0\", 3);");
        #} else {
                $self->output("                int retval = $prefix$field->{short_typename}_new(&(*ret)->$field->{name});\n");
        #}

        $self->output("
                if ( retval < 0 ) {
                        idmef_$struct->{short_typename}_destroy(*ret);
                        *ret = NULL;
                        return retval;
                }
        }
");

        if ( $field->{typename} eq "idmef_time_t" and $field->{name} eq "create_time" and ($struct->{short_typename} eq "alert" or $struct->{short_typename} eq "heartbeat") ) {
                $self->output("
        idmef_time_set_from_gettimeofday((*ret)->$field->{name});
");
        }

        }

    }

    $self->output("
        return 0;

\}
");
}

sub     struct_get_child
{
    my  $self = shift;
    my  $tree = shift;
    my  $struct = shift;
    my  $n = 0;

    $self->output("
int _idmef_$struct->{short_typename}_get_child(void *p, idmef_class_child_id_t child, void **childptr)
\{
        $struct->{typename} *ptr = p;

        prelude_return_val_if_fail(p, prelude_error(PRELUDE_ERROR_ASSERTION));
        *childptr = NULL;

        switch ( child ) \{
");

    foreach my $field ( @{ $struct->{field_list} } ) {

        if ( $field->{metatype} & &METATYPE_LIST ) {

            $self->output("
                case $n:
                        *childptr = &ptr->$field->{name};
                        return 0;
");
        } elsif ( $field->{metatype} & &METATYPE_UNION ) {

            foreach my $member ( @{ $field->{member_list} } ) {
                $self->output("
                case $n:
                        *childptr = ( ptr->$field->{var} == $member->{value} ) ? ptr->$field->{name}.$member->{name} : NULL;
                        return 0;
");
                $n++;
            }
        }

        elsif ( $field->{metatype} & &METATYPE_ENUM ) {
            $self->output("
                case $n:");

            if ( $field->{metatype} & &METATYPE_OPTIONAL_INT ) {
                $self->output("
                       if ( ! ptr->$field->{name}_is_set )
                               return 0;");
            }

            $self->output("
                       return idmef_value_new_enum_from_numeric((idmef_value_t **) childptr,
                                                                IDMEF_CLASS_ID_" . uc($field->{short_typename}) . ", ptr->$field->{short_name});
");
        } elsif ( $field->{metatype} & (&METATYPE_OPTIONAL_INT) ) {
           if ( $field->{metatype} & &METATYPE_OPTIONAL_INT ) {
            $self->output("
                case $n:
                       return (ptr->$field->{name}_is_set) ? idmef_value_new_$field->{value_type}((idmef_value_t **) childptr, ptr->$field->{name}) : 0;
");
        }

        } elsif ( $field->{metatype} & (&METATYPE_PRIMITIVE) ) {
            $self->output("
                case $n:");

            if ( $field->{metatype} & &METATYPE_OPTIONAL_INT ) {
                $self->output("
                       if ( ! ptr->$field->{name}_is_set )
                               return 0;");
            }

            if ( $field->{typename} eq "prelude_string_t" ) {
                my $refer = $field->{ptr} ? "" : "&";
                my $owned = $field->{ptr} ? "TRUE" : "FALSE";
                $self->output("
                       return get_value_from_string((idmef_value_t **) childptr, $refer ptr->$field->{name}, $owned);");
            }
            elsif ( $field->{typename} eq "idmef_data_t" ) {
                my $refer = $field->{ptr} ? "" : "&";
                my $owned = $field->{ptr} ? "TRUE" : "FALSE";
                $self->output("
                       return get_value_from_data((idmef_value_t **) childptr, $refer ptr->$field->{name}, $owned);");
            } elsif ( $field->{typename} eq "idmef_time_t" ) {
                my $refer = $field->{ptr} ? "" : "&";
                my $owned = $field->{ptr} ? "TRUE" : "FALSE";
                $self->output("
                       return get_value_from_time((idmef_value_t **) childptr, $refer ptr->$field->{name}, $owned);");
            }

            else {
                $self->output("
                       return idmef_value_new_$field->{value_type}((idmef_value_t **) childptr, ptr->$field->{name});");
            }

        } else {
            my $refer = $field->{ptr} ? "" : "&";

            $self->output("
                case ${n}:
                        *childptr = ${refer}ptr->$field->{name};
                        return 0;
");
        }

        $n++;
    }

    $self->output("
                default:
                        return prelude_error(PRELUDE_ERROR_IDMEF_CLASS_UNKNOWN_CHILD);
        \}
\}
");
}



sub     struct_destroy_child
{
    my  $self = shift;
    my  $tree = shift;
    my  $struct = shift;
    my  $n = 0;

    $self->output("
int _idmef_$struct->{short_typename}_destroy_child(void *p, idmef_class_child_id_t child, int n)
\{
        $struct->{typename} *ptr = p;

        prelude_return_val_if_fail(p, prelude_error(PRELUDE_ERROR_ASSERTION));

        switch ( child ) \{
");

    foreach my $field ( @{ $struct->{field_list} } ) {

        if ( $field->{metatype} & &METATYPE_LIST ) {
                my $type = "";

                if ( $field->{typename} eq "idmef_time_t" ||
                     $field->{typename} eq "idmef_data_t" ||
                     $field->{typename} eq "prelude_string_t" ) {
                        $type = "$field->{short_typename}"
                } else {
                        $type = "idmef_$field->{short_typename}"
                }

            $self->output("
                case $n: \{
                        int i = 0;
                        prelude_list_t *tmp;

                        if ( n >= 0 ) {
                               prelude_list_for_each(&ptr->$field->{name}, tmp) {
                                       if ( i++ == n ) {
                                               void *b = prelude_linked_object_get_object(tmp);
                                               ${type}_destroy(b);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return prelude_error(PRELUDE_ERROR_IDMEF_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               prelude_list_for_each_reversed(&ptr->$field->{name}, tmp) {
                                       if ( i++ == pos ) {
                                               void *b = prelude_linked_object_get_object(tmp);
                                               ${type}_destroy(b);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return prelude_error(PRELUDE_ERROR_IDMEF_TREE_INDEX_UNDEFINED);
                        }
                \}
");
        } elsif ( $field->{metatype} & &METATYPE_UNION ) {

            foreach my $member ( @{ $field->{member_list} } ) {
                $self->output("
                case $n:
                        if (  ptr->$field->{var} != $member->{value} )
                                return 0;

                        idmef_$member->{short_typename}_destroy(ptr->$field->{name}.$member->{name});
                        ptr->$field->{name}.$member->{name} = NULL;
                        ptr->$field->{var} = 0;

                        return 0;
");
                $n++;
            }

        } elsif ( $field->{metatype} & &METATYPE_NORMAL ) {
            if ( $field->{metatype} & &METATYPE_OPTIONAL_INT ) {
                $self->output("
                case $n:
                        ptr->$field->{name}_is_set = 0;
                        return 0;
");
            }

            elsif ( $field->{ptr} ) {
                my $type = "";

                if ( $field->{typename} eq "idmef_time_t" ||
                     $field->{typename} eq "idmef_data_t" ||
                     $field->{typename} eq "prelude_string_t" ) {
                        $type = "$field->{short_typename}"
                } else {
                        $type = "idmef_$field->{short_typename}"
                }

                $self->output("
                case $n:
                        if ( ptr->$field->{name} ) {
                                ${type}_destroy(ptr->$field->{name});
                                ptr->$field->{name} = NULL;
                        }

                        return 0;
");
            }

            else {
                my $code = "";

                if ( $field->{metatype} & &METATYPE_ENUM)  {
                        $code = "ptr->$field->{name} = 0";
                }

                elsif ( ! ($field->{metatype} & &METATYPE_STRUCT) ) {
                        $n++;
                        next;
                }
                elsif ( $field->{typename} eq "idmef_time_t" ||
                     $field->{typename} eq "idmef_data_t" ||
                     $field->{typename} eq "prelude_string_t" ) {
                        $code = "$field->{short_typename}_destroy_internal(&ptr->$field->{name})"
                } else {
                        $code = "idmef_$field->{short_typename}_destroy_internal(&ptr->$field->{name})"
                }

                $self->output("
                case $n:
                        ${code};
                        return 0;
");
            }

        }

        $n++;
    }

    $self->output("
                default:
                        return prelude_error(PRELUDE_ERROR_IDMEF_CLASS_UNKNOWN_CHILD);
        \}
\}
");
}


sub     struct_new_child
{
    my  $self = shift;
    my  $tree = shift;
    my  $struct = shift;
    my  $n = 0;

    $self->output("
int _idmef_$struct->{short_typename}_new_child(void *p, idmef_class_child_id_t child, int n, void **ret)
\{
        $struct->{typename} *ptr = p;

        prelude_return_val_if_fail(p, prelude_error(PRELUDE_ERROR_ASSERTION));

        switch ( child ) \{
");

    foreach my $field ( @{ $struct->{field_list} } ) {

        if ( $field->{metatype} & &METATYPE_LIST ) {
            $self->output("
                case $n: \{
                        int i = 0;
                        prelude_list_t *tmp;

                        if ( n == IDMEF_LIST_APPEND || n == IDMEF_LIST_PREPEND )
                               return idmef_$struct->{short_typename}_new_$field->{short_name}(ptr, ($field->{typename} **) ret, n);

                        if ( n >= 0 ) {
                               prelude_list_for_each(&ptr->$field->{name}, tmp) {
                                       if ( i++ == n ) {
                                               *ret = prelude_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return prelude_error(PRELUDE_ERROR_IDMEF_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               prelude_list_for_each_reversed(&ptr->$field->{name}, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = prelude_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return prelude_error(PRELUDE_ERROR_IDMEF_TREE_INDEX_UNDEFINED);
                        }

                        return idmef_$struct->{short_typename}_new_$field->{short_name}(ptr, ($field->{typename} **) ret, n);
                \}
");
        } elsif ( $field->{metatype} & &METATYPE_UNION ) {

            foreach my $member ( @{ $field->{member_list} } ) {
                $self->output("
                case $n:
                        return idmef_$struct->{short_typename}_new_$member->{name}(ptr, ($member->{typename} **) ret);
");
                $n++;
            }

        } elsif ( $field->{metatype} & &METATYPE_NORMAL ) {
            $self->output("
                case $n:
                        return idmef_$struct->{short_typename}_new_$field->{name}(ptr, ($field->{typename} **) ret);
");
        }

        $n++;
    }

    $self->output("
                default:
                        return prelude_error(PRELUDE_ERROR_IDMEF_CLASS_UNKNOWN_CHILD);
        \}
\}
");
}


sub     struct_copy
{
    my  $self = shift;
    my  $tree = shift;
    my  $struct = shift;

    $self->output("
/**
 * idmef_$struct->{short_typename}_copy:
 * \@src: Source of the copy.
 * \@dst: Where to copy the object.
 *
 * Copy a new #$struct->{typename} object from \@src to \@dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmef_$struct->{short_typename}_copy(const $struct->{typename} *src, $struct->{typename} *dst)
\{
        int ret;

        prelude_return_val_if_fail(src, prelude_error(PRELUDE_ERROR_ASSERTION));
        prelude_return_val_if_fail(dst, prelude_error(PRELUDE_ERROR_ASSERTION));

        ret = 0;
");

    foreach my $field ( @{ $struct->{field_list} } ) {
        my $clone_func = "$field->{short_typename}_clone";
        my $copy_func = "$field->{short_typename}_copy";
        my $destroy_func = "$field->{short_typename}_destroy";

        if ( ! ($field->{metatype} & &METATYPE_PRIMITIVE) ) {
            $clone_func = "idmef_${clone_func}";
            $copy_func = "idmef_${copy_func}";
            $destroy_func = "idmef_${destroy_func}";
        }

        if ( $field->{metatype} & &METATYPE_LIST ) {
            $self->output("
        \{
                prelude_list_t *n, *tmp;
                $field->{typename} *entry, *new;

                prelude_list_for_each_safe(&dst->$field->{name}, tmp, n) \{
                        entry = prelude_linked_object_get_object(tmp);
                        $destroy_func(entry);
                \}

                prelude_list_for_each_safe(&src->$field->{name}, tmp, n) \{
                        entry = prelude_linked_object_get_object(tmp);
                        $clone_func(entry, &new);
                        prelude_list_add_tail(&dst->$field->{name}, &((prelude_linked_object_t *) new)->_list);
                \}
        \}
");

        } elsif ( $field->{metatype} & &METATYPE_UNION ) {
            $self->output("
        switch ( dst->$field->{var} ) {
");

            foreach my $member ( @{ $field->{member_list} } ) {

                $self->output("
                case $member->{value}:
                        idmef_$member->{short_typename}_destroy(dst->$field->{name}.$member->{name});
                        break;
");
            }
            $self->output("
                default:
                        break;
        }
");

            $self->output("
        switch ( src->$field->{var} ) {
");

            foreach my $member ( @{ $field->{member_list} } ) {

                $self->output("
                case $member->{value}:
                        ret = idmef_$member->{short_typename}_clone(src->$field->{name}.$member->{name}, &dst->$field->{name}.$member->{name});
                        break;
");
            }
            $self->output("
                default:
                        break;
        }

        if ( ret < 0 )
               return ret;

        dst->$field->{var} = src->$field->{var};
");
        } elsif ( $field->{metatype} & &METATYPE_STRUCT ) {
            if ( $field->{required} ) {
                $self->output("
        if ( src->$field->{name} ) {
                ret = ${copy_func}(src->$field->{name}, dst->$field->{name});
                if ( ret < 0 )
                        return ret;
        }
");

            }

            elsif ( $field->{ptr} ) {
                $self->output("
        if ( dst->$field->{name} ) {
                ${destroy_func}(dst->$field->{name});
                dst->$field->{name} = NULL;
        }

        if ( src->$field->{name} ) {
                ret = ${clone_func}(src->$field->{name}, &dst->$field->{name});
                if ( ret < 0 )
                        return ret;
        }
");
            } else {
                $self->output("
        ret = $copy_func(&src->$field->{name}, &dst->$field->{name});
        if ( ret < 0 )
                return ret;
");
            }
        } else {
            if ( $field->{metatype} & &METATYPE_OPTIONAL_INT ) {
                        $self->output("
        dst->$field->{name}_is_set = src->$field->{name}_is_set;
");
            }
            $self->output("
        dst->$field->{name} = src->$field->{name};
");
        }
    }

    $self->output("
        return 0;
\}
");
}



sub     struct_clone
{
    my  $self = shift;
    my  $tree = shift;
    my  $struct = shift;

    $self->output("
/**
 * idmef_$struct->{short_typename}_clone:
 * \@src: Object to be cloned.
 * \@dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of \@src, and store it in \@dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int idmef_$struct->{short_typename}_clone($struct->{typename} *src, $struct->{typename} **dst)
\{
        int ret;

        prelude_return_val_if_fail(src, prelude_error(PRELUDE_ERROR_ASSERTION));

        ret = idmef_$struct->{short_typename}_new(dst);
        if ( ret < 0 )
                return ret;

        return idmef_$struct->{short_typename}_copy(src, *dst);
\}
");
}


sub     struct_cmp
{
    my  $self = shift;
    my  $tree = shift;
    my  $struct = shift;

    $self->output("
/**
 * idmef_$struct->{short_typename}_compare:
 * \@obj1: Object to compare with \@obj2.
 * \@obj2: Object to compare with \@obj1.
 *
 * Compare \@obj1 with \@obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int idmef_$struct->{short_typename}_compare(const $struct->{typename} *obj1, const $struct->{typename} *obj2)
\{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )
                return -1;
");

    foreach my $field ( @{ $struct->{field_list} } ) {
        my $compare_func = "$field->{short_typename}_compare";

        if ( ! ($field->{metatype} & &METATYPE_PRIMITIVE) ) {
            $compare_func = "idmef_${compare_func}";
        }

        if ( $field->{metatype} & &METATYPE_LIST ) {
            $self->output("
        \{
                prelude_list_t *tmp1, *tmp2;
                $field->{typename} *entry1, *entry2;

                tmp1 = tmp2 = NULL;
                do \{
                        entry1 = entry2 = NULL;

                        prelude_list_for_each_continue(&obj1->$field->{name}, tmp1) \{
                                entry1 = prelude_linked_object_get_object(tmp1);
                                break;
                        \}

                        prelude_list_for_each_continue(&obj2->$field->{name}, tmp2) \{
                                entry2 = prelude_linked_object_get_object(tmp2);
                                break;
                        \}

                        ret = $compare_func(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                \} while ( entry1 && entry2 );
        \}
");

        } elsif ( $field->{metatype} & &METATYPE_UNION ) {
            $self->output("
        if ( obj1->$field->{var} != obj2->$field->{var} )
                return -1;

        switch ( obj1->$field->{var} ) {
");

            foreach my $member ( @{ $field->{member_list} } ) {

                $self->output("
                case $member->{value}:
                        ret = idmef_$member->{short_typename}_compare(obj1->$field->{name}.$member->{name}, obj2->$field->{name}.$member->{name});
                        break;
");
            }
            $self->output("
                default:
                        break;
        }
");
        } elsif ( $field->{metatype} & &METATYPE_STRUCT ) {
            if ( $field->{ptr} ) {
                $self->output("
        ret = $compare_func(obj1->$field->{name}, obj2->$field->{name});
        if ( ret != 0 )
                return ret;
");
            } else {
                $self->output("
        ret = $compare_func(&obj1->$field->{name}, &obj2->$field->{name});
        if ( ret != 0 )
                return ret;
");
            }
        } else {
            if ( $field->{metatype} & &METATYPE_OPTIONAL_INT ) {
                        $self->output("
        if ( obj1->$field->{name}_is_set != obj2->$field->{name}_is_set )
                return -1;

        if ( obj1->$field->{name}_is_set && obj1->$field->{name} != obj2->$field->{name} )
                return -1;
");
            } else {
                if ( $field->{typename} eq "float" ) {
                        $self->output("
        ret = float_compare(obj1->$field->{name}, obj2->$field->{name});
");
                } else {
                        $self->output("
        if ( obj1->$field->{name} != obj2->$field->{name} )
                return -1;
");
                }
            }
        }
    }

    $self->output("
        return ret;
\}
");
}



sub     struct_destroy_internal
{
    my  $self = shift;
    my  $tree = shift;
    my  $struct = shift;

    $self->output("
static void idmef_$struct->{short_typename}_destroy_internal($struct->{typename} *ptr)
\{
        prelude_return_if_fail(ptr);
");

    $self->output("
       if ( ! prelude_list_is_empty(&((prelude_linked_object_t *)ptr)->_list) )
               prelude_list_del_init(&((prelude_linked_object_t *)ptr)->_list);
    ") if ( $struct->{is_listed} );

    foreach my $field ( @{ $struct->{field_list} } ) {
        my $destroy_func = "$field->{short_typename}_destroy";
        my $destroy_internal_func = "${destroy_func}_internal";

        if ( ! ($field->{metatype} & &METATYPE_PRIMITIVE) ) {
            $destroy_func = "idmef_${destroy_func}";
            $destroy_internal_func = "idmef_$destroy_internal_func";
        }

        if ( $field->{metatype} & &METATYPE_LIST ) {

            $self->output("
        \{
                prelude_list_t *n, *tmp;
                $field->{typename} *entry;

                prelude_list_for_each_safe(&ptr->$field->{name}, tmp, n) \{
                        entry = prelude_linked_object_get_object(tmp);
                        prelude_list_del_init(tmp);
                        $destroy_func(entry);
                \}
        \}
");

        } elsif ( $field->{metatype} & &METATYPE_UNION ) {
            $self->output("
        switch ( ptr->$field->{var} ) {
");

            foreach my $member ( @{ $field->{member_list} } ) {

                $self->output("
                case $member->{value}:
                        idmef_$member->{short_typename}_destroy(ptr->$field->{name}.$member->{name});
                        ptr->$field->{name}.$member->{name} = NULL;
                        break;
");
            }
            $self->output("
                default:
                        break;
        }
");
        } elsif ( $field->{metatype} & &METATYPE_STRUCT ) {
            if ( $field->{ptr} ) {
                $self->output("
        if ( ptr->$field->{name} ) \{
                ${destroy_func}(ptr->$field->{name});
                ptr->$field->{name} = NULL;
        \}
");
            } else {
                $self->output("
        ${destroy_internal_func}(&ptr->$field->{name});
");
            }
        } elsif ( $field->{metatype} & &METATYPE_PRIMITIVE ) {

            if ( $field->{ptr} ) {
                $self->output("
        if ( ptr->$field->{name} )
                free(ptr->$field->{name});
");
            }
        }
    }

    $self->output("

        /* free() should be done by the caller */
\}
");
}

sub     struct_destroy
{
    my  $self = shift;
    my  $tree = shift;
    my  $struct = shift;

    return if ( $struct->{toplevel} );

    $self->output("
/**
 * idmef_$struct->{short_typename}_destroy:
 * \@ptr: pointer to a #$struct->{typename} object.
 *
 * Destroy \@ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
");

    if ( $struct->{refcount} ) {
        $self->output("
void idmef_$struct->{short_typename}_destroy($struct->{typename} *ptr)
\{
        prelude_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        idmef_$struct->{short_typename}_destroy_internal(ptr);
        free(ptr);
\}
");

    } else {
        $self->output("
void idmef_$struct->{short_typename}_destroy($struct->{typename} *ptr)
\{
        prelude_return_if_fail(ptr);

        idmef_$struct->{short_typename}_destroy_internal(ptr);
        free(ptr);
\}
");
    }
}

sub     struct_ref
{
    my  $self = shift;
    my  $tree = shift;
    my  $struct = shift;

    $struct->{refcount} or return;

    $self->output("
/**
 * idmef_$struct->{short_typename}_ref:
 * \@$struct->{short_typename}: pointer to a #$struct->{typename} object.
 *
 * Increase \@$struct->{short_typename} reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to \@$struct->{short_typename}.
 */
$struct->{typename} *idmef_$struct->{short_typename}_ref($struct->{typename} *$struct->{short_typename})
\{
        prelude_return_val_if_fail($struct->{short_typename}, NULL);
        $struct->{short_typename}->refcount++;

        return $struct->{short_typename};
\}
");
}

sub     struct_field_normal
{
    my  $self = shift;
    my  $tree = shift;
    my  $struct = shift;
    my  $field = shift;
    my  $name = shift || $field->{name};
    my  $ptr = "";
    my  $refer = "";

    if ( $field->{ptr} ) {
        if ( $field->{metatype} & &METATYPE_STRUCT ) {
            $ptr = "*";

        } else {
            $refer = "*";
        }

    } else {
        if ( $field->{metatype} & (&METATYPE_STRUCT|&METATYPE_OPTIONAL_INT) ) {
            $ptr = "*";
            $refer = "&";
        }
    }

    ##############################
    # Generate *_get_* functions #
    ##############################

    $self->output("
/**
 * idmef_$struct->{short_typename}_get_${name}:
 * \@ptr: pointer to a #$struct->{typename} object.
 *
 * Get ${name} children of the #$struct->{typename} object.
 *
 * Returns: a pointer to a $field->{typename} object, or NULL if the children object is not set.
 */
$field->{typename} ${ptr}idmef_$struct->{short_typename}_get_${name}($struct->{typename} *ptr)
\{
        prelude_return_val_if_fail(ptr, 0); /* FIXME */
");

    if ( $field->{metatype} & &METATYPE_OPTIONAL_INT ) {
        $self->output("
        return ptr->$field->{name}_is_set ? &ptr->$field->{name} : NULL;");

    } elsif ( $field->{metatype} & &METATYPE_PRIMITIVE && !($field->{metatype} & &METATYPE_STRUCT) && $field->{ptr}) {
        $self->output("
        return ptr->$field->{name} ? *ptr->$field->{name} : ($field->{typename}) 0;");

    } else {
        $self->output("
        return ${refer}ptr->$field->{name};");
    }

    $self->output("
\}
");


    ##############################
    # Generate *_set_* functions #
    ##############################

    my $field_name = ($field->{"name"} eq "class") ? "class_str" : $field->{name};


    $self->output("
/**
 * idmef_$struct->{short_typename}_set_$field->{name}:
 * \@ptr: pointer to a #$struct->{typename} object.
 * \@$field_name: pointer to a #$field->{typename} object.
 *
 * Set \@$field_name object as a children of \@ptr.
 * if \@ptr already contain an \@$field_name object, then it is destroyed,
 * and updated to point to the provided \@$field_name object.
 */
");

    if ( $field->{metatype} & &METATYPE_OPTIONAL_INT ) {
        $self->output("
void idmef_$struct->{short_typename}_set_$field->{name}($struct->{typename} *ptr, $field->{typename} $field_name)
\{
        prelude_return_if_fail(ptr);
        ptr->$field->{name} = $field_name;
        ptr->$field->{name}_is_set = 1;
\}


void idmef_$struct->{short_typename}_unset_$field->{name}($struct->{typename} *ptr)
\{
        prelude_return_if_fail(ptr);
        ptr->$field->{name}_is_set = 0;
\}

");

    } elsif ( $field->{metatype} & &METATYPE_STRUCT ) {
        if ( $field->{ptr} ) {
            my $destroy_func = "$field->{short_typename}_destroy";

            $destroy_func = "idmef_${destroy_func}" if ( ! ($field->{metatype} & &METATYPE_PRIMITIVE) );

            $self->output("
void idmef_$struct->{short_typename}_set_$field->{name}($struct->{typename} *ptr, $field->{typename} *$field_name)
\{
        prelude_return_if_fail(ptr);

        if ( ptr->$field->{name} )
                ${destroy_func}(ptr->$field->{name});

        ptr->$field->{name} = $field_name;
\}
");
        } else {
            my $destroy_internal_func = "$field->{short_typename}_destroy_internal";

            $destroy_internal_func = "idmef_${destroy_internal_func}" if ( ! ($field->{metatype} & &METATYPE_PRIMITIVE) );

            $self->output("
void idmef_$struct->{short_typename}_set_$field->{name}($struct->{typename} *ptr, $field->{typename} *$field_name)
\{
        prelude_return_if_fail(ptr);

        ${destroy_internal_func}(&ptr->$field->{name});
        if ( $field_name ) {
                memcpy(&ptr->$field->{name}, $field_name, sizeof(ptr->$field->{name}));
                free($field->{name});
        }
\}
");
        }
    } else {
        if ( $field->{ptr} ) {
            $self->output("
void idmef_$struct->{short_typename}_set_$field->{name}($struct->{typename} *ptr, $field->{typename} $field_name)
\{
        prelude_return_if_fail(ptr);

        if ( ptr->$field->{name} )
                free(ptr->$field->{name});

        ptr->$field->{name} = malloc(sizeof (*ptr->$field->{name}));
        prelude_return_if_fail(ptr->$field->{name});

        *ptr->$field->{name} = $field_name;
\}
");

        } else {
            $self->output("
void idmef_$struct->{short_typename}_set_$field->{name}($struct->{typename} *ptr, $field->{typename} $field_name)
\{
        prelude_return_if_fail(ptr);
        ptr->$field->{name} = $field_name;
");

        if ( $struct->{typename} eq "idmef_additional_data_t" and $name eq "type" ) {
                $self->output("
        ptr->_type_is_set = TRUE;

");
        }

$self->output("\}
");
        }
    }

    ##############################
    # Generate *_new_* functions #
    ##############################

    $self->output("
/**
 * idmef_$struct->{short_typename}_new_${name}:
 * \@ptr: pointer to a #$struct->{typename} object.
 * \@ret: pointer to an address where to store the created #$field->{typename} object.
 *
 * Create a new ${name} object, children of #$struct->{typename}.
 * If \@ptr already contain a #$field->{typename} object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmef_$struct->{short_typename}_new_${name}($struct->{typename} *ptr, $field->{typename} **ret)
\{");
    my $need_check = 1;

    if ( $field->{metatype} & &METATYPE_OPTIONAL_INT ) {
        $need_check = 0;
        $self->output("
        prelude_return_val_if_fail(ptr, prelude_error(PRELUDE_ERROR_ASSERTION));
        ptr->$field->{name}_is_set = 1;
");
    } elsif ( $field->{metatype} & &METATYPE_PRIMITIVE ) {

        if ( $field->{metatype} & &METATYPE_STRUCT ) {

            if ( $field->{ptr} ) {
                $need_check = 0;

                $self->output("
        int retval;

        prelude_return_val_if_fail(ptr, prelude_error(PRELUDE_ERROR_ASSERTION));

        if ( ! ptr->$field->{name} ) {
                retval = $field->{short_typename}_new(&ptr->$field->{name});
                if ( retval < 0 )
                        return retval;
        }
");
            }
        }
    } else {
        if ( $field->{metatype} & &METATYPE_STRUCT ) {
            if ( $field->{ptr} ) {
                $need_check = 0;

                $self->output("
        int retval;

        prelude_return_val_if_fail(ptr, prelude_error(PRELUDE_ERROR_ASSERTION));

        if ( ! ptr->$field->{name} ) {
                retval = idmef_$field->{short_typename}_new(&ptr->$field->{name});
                if ( retval < 0 )
                        return retval;
        }
");
            } else {
                if ( $tree->{objs}->{$field->{typename}}->{is_listed} ) {
                     $need_check = 0;
                     $self->output("
        prelude_return_val_if_fail(ptr, prelude_error(PRELUDE_ERROR_ASSERTION));
        prelude_list_init(&ptr->$field->{name}._list);");
                 }
            }
        }
    }

    $refer = $field->{ptr} ? "" : "&";

    if ( $need_check ) {
        $self->output("
        prelude_return_val_if_fail(ptr, prelude_error(PRELUDE_ERROR_ASSERTION));
");
    }

    if ( $field->{typename} eq "idmef_additional_data_type_t" and $field->{name} eq "type" ) {
       $self->output("        ptr->_type_is_set = TRUE;");
    }

    $self->output("
        *ret = ${refer}ptr->$field->{name};
        return 0;
\}
");
}

sub     struct_field_union
{
    my  $self = shift;
    my  $tree = shift;
    my  $struct = shift;
    my  $field = shift;

    $self->output("
/**
 * idmef_$struct->{short_typename}_get_$field->{var}:
 * \@ptr: pointer to a #$struct->{typename} object.
 *
 * Access the $field->{var} children of \@ptr.
 *
 * Returns: a pointer to the #$field->{typename} children, or NULL if it is not set.
 */
$field->{typename} idmef_$struct->{short_typename}_get_$field->{var}($struct->{typename} *ptr)
\{
        prelude_return_val_if_fail(ptr, prelude_error(PRELUDE_ERROR_ASSERTION));
        return ptr->$field->{var};
\}
");

    foreach my $member ( @{ $field->{member_list} } ) {
        $self->output("
/**
 * idmef_$struct->{short_typename}_get_$member->{name}:
 * \@ptr: pointer to a #$struct->{typename} object.
 *
 * Access the $member->{name} children of \@ptr.
 *
 * Returns: a pointer to the #$member->{typename} children, or NULL if it is not set.
 */
$member->{typename} *idmef_$struct->{short_typename}_get_$member->{name}($struct->{typename} *ptr)
\{
        prelude_return_val_if_fail(ptr, NULL);
        return (ptr->$field->{var} == $member->{value}) ? ptr->$field->{name}.$member->{name} : NULL;
\}
"
);

        $self->output("
/**
 * idmef_$struct->{short_typename}_set_$member->{name}:
 * \@ptr: pointer to a #$struct->{typename} object.
 * \@$member->{name}: pointer to a #$member->{typename} object.
 *
 * Set \@$member->{name} object as a children of \@ptr.
 * if \@ptr already contain a \@$member->{name} object, then it is destroyed,
 * and updated to point to the provided \@$member->{name} object.
 */
void idmef_$struct->{short_typename}_set_$member->{name}($struct->{typename} *ptr, $member->{typename} *$member->{name})
\{
        prelude_return_if_fail(ptr);

        switch ( ptr->$field->{var} ) \{
");
        foreach my $member ( @{ $field->{member_list} } ) {
            $self->output("
                case $member->{value}:
                        idmef_$member->{short_typename}_destroy(ptr->$field->{name}.$member->{name});
                        break;
");
        }

        $self->output("
                default:
                        break;
        \}

        ptr->$field->{name}.$member->{name} = $member->{name};
        ptr->$field->{var} = ($member->{name}) ? $member->{value} : 0;
\}
");

        $self->output("
/**
 * idmef_$struct->{short_typename}_new_$member->{name}:
 * \@ptr: pointer to a #$struct->{typename} object.
 * \@ret: pointer where to store the created #$member->{typename} object.
 *
 * Create a new $member->{typename} object, children of #$struct->{typename}.
 * If \@ptr already contain a #$member->{typename} object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmef_$struct->{short_typename}_new_$member->{name}($struct->{typename} *ptr, $member->{typename} **ret)
\{
        int retval;

        prelude_return_val_if_fail(ptr, prelude_error(PRELUDE_ERROR_ASSERTION));

        switch ( ptr->$field->{var} ) \{
");
        foreach my $other_member ( @{ $field->{member_list} } ) {

            if ( $other_member == $member ) {
                $self->output("
                case $member->{value}:
                        *ret = ptr->$field->{name}.$member->{name};
                        return 0;
");
            } else {
                $self->output("
                case $other_member->{value}:
                        idmef_$other_member->{short_typename}_destroy(ptr->$field->{name}.$other_member->{name});
                        break;
");
            }
        }

        $self->output("
                default:
                        break;
        \}

        retval = idmef_$member->{short_typename}_new(ret);
        if ( retval < 0 )
                return retval;

        ptr->$field->{var} = $member->{value};
        ptr->$field->{name}.$member->{name} = *ret;

        return 0;
\}
");
    }
}

sub     struct_field_list
{
    my  $self = shift;
    my  $tree = shift;
    my  $struct = shift;
    my  $field = shift;
    my  $new_field_function = "$field->{short_typename}_new(ret)";

    $new_field_function = "idmef_${new_field_function}" if ( ! ($field->{metatype} & &METATYPE_PRIMITIVE) );

    $self->output("
/**
 * idmef_$struct->{short_typename}_get_next_$field->{short_name}:
 * \@$struct->{short_typename}: pointer to a #$struct->{typename} object.
 * \@$field->{short_typename}_cur: pointer to a #$field->{typename} object.
 *
 * Get the next #$field->{typename} object listed in \@ptr.
 * When iterating over the $field->{typename} object listed in \@ptr,
 * \@object should be set to the latest returned #$field->{typename} object.
 *
 * Returns: the next #$field->{typename} in the list.
 */
$field->{typename} *idmef_$struct->{short_typename}_get_next_$field->{short_name}($struct->{typename} *$struct->{short_typename}, $field->{typename} *$field->{short_typename}_cur)
\{
        prelude_list_t *tmp = ($field->{short_typename}_cur) ? &((prelude_linked_object_t *) $field->{short_typename}_cur)->_list : NULL;

        prelude_return_val_if_fail($struct->{short_typename}, NULL);

        prelude_list_for_each_continue(&$struct->{short_typename}->$field->{name}, tmp)
                return prelude_linked_object_get_object(tmp);

        return NULL;
\}


/**
 * idmef_$struct->{short_typename}_set_$field->{short_name}:
 * \@ptr: pointer to a #$struct->{typename} object.
 * \@object: pointer to a #$field->{typename} object.
 * \@pos: Position in the list.
 *
 * Add \@object to position \@pos of \@ptr list of #$field->{typename} object.
 *
 * If \@pos is #IDMEF_LIST_APPEND, \@object will be inserted at the tail of the list.
 * If \@pos is #IDMEF_LIST_PREPEND, \@object will be inserted at the head of the list.
 */
void idmef_$struct->{short_typename}_set_$field->{short_name}($struct->{typename} *ptr, $field->{typename} *object, int pos)
\{
        prelude_return_if_fail(ptr);
        prelude_return_if_fail(object);

        if ( ! prelude_list_is_empty(&((prelude_linked_object_t *) object)->_list) )
                prelude_list_del_init(&((prelude_linked_object_t *) object)->_list);

        list_insert(&ptr->$field->{name}, &((prelude_linked_object_t *) object)->_list, pos);
\}


/**
 * idmef_$struct->{short_typename}_new_$field->{short_name}:
 * \@ptr: pointer to a #$struct->{typename} object.
 * \@ret: pointer to an address where to store the created #$field->{typename} object.
 * \@pos: position in the list.
 *
 * Create a new #$field->{typename} children of \@ptr, and add it to position \@pos of
 * \@ptr list of #$field->{typename} object. The created #$field->{typename} object is
 * stored in \@ret.
 *
 * If \@pos is #IDMEF_LIST_APPEND, \@object will be inserted at the tail of the list.
 * If \@pos is #IDMEF_LIST_PREPEND, \@object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int idmef_$struct->{short_typename}_new_$field->{short_name}($struct->{typename} *ptr, $field->{typename} **ret, int pos)
\{
        int retval;

        prelude_return_val_if_fail(ptr, prelude_error(PRELUDE_ERROR_ASSERTION));

        retval = $new_field_function;
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->$field->{name}, &((prelude_linked_object_t *)(*ret))->_list, pos);

        return 0;
\}

");
}

sub        struct_fields
{
    my        $self = shift;
    my        $tree = shift;
    my        $struct = shift;

    foreach my $field ( @{ $struct->{field_list} } ) {
        $self->struct_field_normal($tree, $struct, $field) if ( $field->{metatype} & &METATYPE_NORMAL );
         $self->struct_field_list($tree, $struct, $field) if ( $field->{metatype} & &METATYPE_LIST );
         $self->struct_field_union($tree, $struct, $field) if ( $field->{metatype} & &METATYPE_UNION );
    }
}

sub        struct
{
    my        $self = shift;
    my        $tree = shift;
    my        $struct = shift;

    $self->struct_desc($tree, $struct);
}

sub        struct_func
{
    my        $self = shift;
    my        $tree = shift;
    my        $struct = shift;

    $self->struct_constructor($tree, $struct);
    $self->struct_ref($tree, $struct);
    $self->struct_get_child($tree, $struct);
    $self->struct_new_child($tree, $struct);
    $self->struct_destroy_child($tree, $struct);
    $self->struct_destroy_internal($tree, $struct);
    $self->struct_destroy($tree, $struct);
    $self->struct_fields($tree, $struct);
    $self->struct_copy($tree, $struct);
    $self->struct_clone($tree, $struct);
    $self->struct_cmp($tree, $struct);
}

sub        enum
{
    my        $self = shift;
    my        $tree = shift;
    my        $enum = shift;

    $self->output("
/**
 * idmef_$enum->{short_typename}_to_numeric:
 * \@name: pointer to an IDMEF string representation of a #$enum->{typename} value.
 *
 * Returns: the numeric equivalent of \@name, or -1 if \@name is not valid.
 */
$enum->{typename} idmef_$enum->{short_typename}_to_numeric(const char *name)
\{
        size_t i;
        const struct {
              $enum->{typename} val;
              const char *name;
        } tbl[] = {");

    foreach my $field ( @{ $enum->{field_list} } ) {
        my $fieldname;

        if ( $field->{text} ) {
            $fieldname = $field->{text};
        } else {
            my $fullname = 'IDMEF_' . uc($enum->{short_typename});

            $fieldname = $field->{name};
            $fieldname =~ s/^${fullname}_//;
            $fieldname = lc($fieldname);
            $fieldname =~ tr/_/-/;
        }

        $self->output("
            { $field->{name}, \"$fieldname\" },");
    }

   $self->output("
        };

        prelude_return_val_if_fail(name, prelude_error(PRELUDE_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return prelude_error_verbose(PRELUDE_ERROR_IDMEF_UNKNOWN_ENUM_STRING, \"Unknown enumeration value '%s' for $enum->{short_typename}\", name);
\}
");

        $self->output("
/**
 * idmef_$enum->{short_typename}_to_string:
 * \@val: an enumeration value for #$enum->{typename}.
 *
 * Return the IDMEF string equivalent of \@val provided #$enum->{typename} value.
 *
 * Returns: a pointer to the string describing \@val, or NULL if \@val is invalid.
 */
const char *idmef_$enum->{short_typename}_to_string($enum->{typename} val)
\{
        const struct {
              $enum->{typename} val;
              const char *name;
        } tbl[] = {");

    my $cnt = 0;

    foreach my $field ( @{ $enum->{field_list} } ) {

        if ( $cnt == 0 && $field->{value} != 0 ) {
            $self->output("{ 0, NULL },");
        }

        my $fieldname;

        if ( $field->{text} ) {
            $fieldname = $field->{text};
        } else {
            my $fullname = 'IDMEF_' . uc($enum->{short_typename});

            $fieldname = $field->{name};
            $fieldname =~ s/^${fullname}_//;
            $fieldname = lc($fieldname);
            $fieldname =~ tr/_/-/;
        }

        $self->output("
                { $field->{name}, \"$fieldname\" },");

        $cnt++;
    }

    $self->output("
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;
\}
");
}


sub footer
{
    my $self = shift;

    $self->output("

int _idmef_additional_data_type_is_set(idmef_additional_data_t *ad)
\{
        return ad->_type_is_set;
\}


void idmef_message_set_pmsg(idmef_message_t *message, prelude_msg_t *msg)
\{
        prelude_return_if_fail(message);
        message->pmsg = msg;
\}


prelude_msg_t *idmef_message_get_pmsg(idmef_message_t *message)
\{
        prelude_return_val_if_fail(message, NULL);
        return message->pmsg;
\}


/**
 * idmef_message_destroy:
 * \@ptr: pointer to a #idmef_message_t object.
 *
 * Destroy \@ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
void idmef_message_destroy(idmef_message_t *ptr)
\{
        prelude_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        idmef_message_destroy_internal(ptr);

        if ( ptr->pmsg )
                prelude_msg_destroy(ptr->pmsg);

        free(ptr);
\}
");

}
1;
